// Generated by CoffeeScript 2.0.0-alpha1
var Events, Pen, Proler, Tags, attrs, body, doc, exists, head, log, pro;

log = console.log;

doc = document;

Proler = function(pro) {
  pro(String).m = function(reg) {
    return this.match(reg);
  };
  pro(String).r = function(reg, str) {
    return this.replace(reg, str);
  };
  pro(String).sw = function(str) {
    return this.startsWith(str);
  };
  pro(String).inc = function(str) {
    return this.includes(str);
  };
  pro(String).ew = function(str) {
    return this.endsWith(str);
  };
  pro(String).toRegExp = function(flags) {
    return new RegExp(this, flags);
  };
  pro(String).splice = function(str, nom) {
    return this.split(str).slice(nom);
  };
  pro(String).reverse = function() {
    var that;
    that = this;
    that = that.split('');
    that = that.reverse();
    that = that.join('');
    return that;
  };
  pro(String).surround = function(str) {
    return `${str}${this}${str.reverse()}`;
  };
  pro(Array).pick = function() {
    return this[Math.floor(Math.random() * this.length)];
  };
  pro(Array).rand = function() {
    return this.pick();
  };
  pro(Array).searchFor = function(str) {
    var i;
    i = 0;
    while (i < this.length) {
      if (this[i].match(str)) {
        return this[i].match(str);
      } else {
        return false;
      }
      i++;
    }
  };
  pro(String).TUCase = function() {
    return this.toUpperCase(this);
  };
  pro(String).TLCase = function() {
    return this.toLowerCase(this);
  };
};

pro = function(arg) {
  return arg.prototype;
};

exists = function(arg) {
  return arg != null;
};

pro(String).getInput = function(reg) {
  var a, str;
  str = this;
  a = void 0;
  while ((a = reg.exec(str)) !== null) {
    if (a.index === reg.lastIndex) {
      reg.lastIndex++;
    }
    return a;
  }
};

Proler(pro);

if (document.body != null) {
  body = document.body;
} else {
  alert("Body is not defined in the html document.");
}

if (document.head != null) {
  head = document.head;
} else {
  alert("Head is not defined in the html document.");
}

Tags = "a link style p pre audio b u s img block video span ul li ol code lable legend div h1 h2 h3 h4 h5 h6 form fieldset input button abbr canvas script br hr table tbody td textarea body head em dl dt header html i iframe colgroup datalist dd del details dfn dialog footer ins kbd main map mark menu ruby rp rt samp section embed wbr source track param meta keygen tr time var area base col ".split(/\s+/);

attrs = "src href type rel style id type value class title width height name charset action align alt async autocomplete autofocus autoplay bgcolor border challenge charset checked cite color cols colspan content contenteditable contextmenu accesskey data dir draggable dropzone hidden lang spellcheck tabindex translate".split(/\s+/);

Events = "blue click change dblclick error focus input keydown keyup keypress load mousedown mousemove mouseover mouseout mouseup resize scroll select submit unload ".split(/\s+/);

Pen = (function() {
  class Pen {
    constructor(auto, stylcon) {
      var style;
      this.auto = auto;
      style = this.create('style');
      if (stylcon != null) {
        style.innerHTML = stylcon;
      }
      head.appendChild(style);
      this.para = this.p('', {
        "class": 'console-log'
      });
      body.appendChild(this.para);
      return;
    }

    changeOption(op) {
      this.auto = op;
    }

    appendToHead(...el) {
      var i, results;
      i = 0;
      results = [];
      while (i < el.length) {
        head.appendChild(el[i]);
        results.push(i++);
      }
      return results;
    }

    appendToBody(...el) {
      var i, results;
      i = 0;
      results = [];
      while (i < el.length) {
        body.appendChild(el[i]);
        results.push(i++);
      }
      return results;
    }

    create(el) {
      return document.createElement(el);
    }

    getIdOf(el) {
      return document.getElementById(el);
    }

    getNameOf(el) {
      return document.getElementsByName(el);
    }

    getClassOf(el) {
      return document.getElementsByClassName(el);
    }

    getTagsOf(el) {
      return document.getElementsByTagName(el);
    }

    select(txt) {
      return document.querySelector(txt);
    }

    selectAll(txt) {
      return document.querySelectorAll(txt);
    }

    checker() {
      if (this.auto === true) {
        return true;
      } else {
        return false;
      }
    }

    autoAppend(el) {
      if (this.checker() === true) {
        body.appendChild(el);
        return el;
      } else {
        return el;
      }
    }

    oEl(el, ...oel) {
      var i;
      if (!oel) {
        return el;
      } else {
        i = 0;
        while (i < oel.length) {
          el.appendChild(oel[i]);
          i++;
        }
      }
      return el;
    }

    createAppend(el) {
      el = this.create(el);
      return this.autoAppend(el);
    }

    checkElement(el) {
      if (typeof el === 'string') {
        el = this.select(el);
      }
      return el;
    }

    createWithObj(el, obj, txt) {
      el = this.create(el);
      el = this.objHandler(el, obj);
      return el;
    }

    createWithText(el, txt) {
      el = this.create(el);
      el.innerHTML = txt;
      return el;
    }


    /*
     * ^^^^^
     * Helpers
     * -------
     * Handlers
     * vvvvv
     */

    objHandler(el, obj, txt) {
      var i, prop;
      if (txt != null) {
        el.innerHTML = txt;
      }
      for (prop in obj) {
        i = 0;
        while (i < attrs.length) {
          if (attrs[i].match(prop.toRegExp("gi"))) {
            el.setAttribute(prop, obj[prop]);
          }
          i++;
        }
      }
      return el;
    }

    automaticHandler(el, txt, obj, ...oel) {
      el = this.create(el);
      el = this.objHandler(el, obj, txt);
      if (oel != null) {
        el = this.oEl(el, ...oel);
      }
      return this.autoAppend(el);
    }


    /*
     * ^^^^^
     * Handlers
     * -------
     * Methods
     * vvvvv
     */

    Html(el, txt) {
      el = this.checkElement(el);
      if (typeof txt === 'object') {
        JSON.parse(txt);
      }
      if (typeof txt === 'function') {
        txt = txt(el);
      }
      el.innerHTML = txt;
      return el;
    }

    Css(el, txt) {
      el = this.checkElement(el);
      el.setAttribute('style', txt);
      return el;
    }

    Id(el, txt) {
      el = this.checkElement(el);
      el.setAttribute('id', txt);
      return el;
    }

    Type(el, txt) {
      el = this.checkElement(el);
      el.setAttribute('type', txt);
      return el;
    }

    On(el, type, fn, cp) {
      el = this.checkElement(el);
      el.addEventListener(type, fn, cp);
      return el;
    }

    Click(el) {
      el = this.checkElement(el);
      el.click();
      return el;
    }

    Append(el, ...el2) {
      var i;
      el = this.checkElement(el);
      i = 0;
      while (i < el2.length) {
        el.appendChild(el2[i]);
        i++;
      }
    }

    write(txt) {
      var cover, link;
      if (txt instanceof Object === true) {
        txt = JSON.stringify(txt);
      }
      if (txt instanceof Array === true) {
        txt = txt.join(', ');
      }
      txt = txt.replace(/;|`n|\\n/gi, '.<br>');
      if (txt.match(/\((.*?)\)\[(.*?)\]/gi)) {
        link = txt.getInput(/\((.*?)\)\[(.*?)\]/gi)[2];
        cover = txt.getInput(/\((.*?)\)\[(.*?)\]/gi)[1];
      }
      txt = txt.replace(/\((.*?)\)\[(.*?)\]/gi, `<a href='${link}' title='${link}'>${cover}</a>`);
      return this.para.innerHTML += txt;
    }

  };


  /*
   * ^^^^^
   * Methods
   * -------
   * Tags
   * vvvvv
   */

  Tags.forEach(function(tag) {
    return Pen.prototype[tag] = function(txt, obj, ...args) {
      return this.automaticHandler(tag, txt, obj, ...args);
    };
  });

  return Pen;

})();
